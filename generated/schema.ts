// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Account extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Account must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Account", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Account | null {
    return changetype<Account | null>(
      store.get_in_block("Account", id.toHexString())
    );
  }

  static load(id: Bytes): Account | null {
    return changetype<Account | null>(store.get("Account", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccessManager(): Bytes | null {
    let value = this.get("asAccessManager");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asAccessManager(value: Bytes | null) {
    if (!value) {
      this.unset("asAccessManager");
    } else {
      this.set("asAccessManager", Value.fromBytes(<Bytes>value));
    }
  }

  get asAccessManaged(): Bytes | null {
    let value = this.get("asAccessManaged");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set asAccessManaged(value: Bytes | null) {
    if (!value) {
      this.unset("asAccessManaged");
    } else {
      this.set("asAccessManaged", Value.fromBytes(<Bytes>value));
    }
  }

  get membership(): AccessManagerRoleMemberLoader {
    return new AccessManagerRoleMemberLoader(
      "Account",
      this.get("id")!.toString(),
      "membership"
    );
  }

  get targettedBy(): AccessManagerTargetLoader {
    return new AccessManagerTargetLoader(
      "Account",
      this.get("id")!.toString(),
      "targettedBy"
    );
  }

  get authorityOf(): AccessManagedLoader {
    return new AccessManagedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "authorityOf"
    );
  }

  get operationCallerOf(): AccessManagedOperationLoader {
    return new AccessManagedOperationLoader(
      "Account",
      this.get("id")!.toString(),
      "operationCallerOf"
    );
  }

  get operationTargetOf(): AccessManagedOperationLoader {
    return new AccessManagedOperationLoader(
      "Account",
      this.get("id")!.toString(),
      "operationTargetOf"
    );
  }

  get operationExecutedSender(): OperationExecutedLoader {
    return new OperationExecutedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "operationExecutedSender"
    );
  }

  get operationScheduledCaller(): OperationScheduledLoader {
    return new OperationScheduledLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "operationScheduledCaller"
    );
  }

  get operationScheduledTarget(): OperationScheduledLoader {
    return new OperationScheduledLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "operationScheduledTarget"
    );
  }

  get operationScheduledSender(): OperationScheduledLoader {
    return new OperationScheduledLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "operationScheduledSender"
    );
  }

  get roleGranted(): RoleGrantedLoader {
    return new RoleGrantedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleGranted"
    );
  }

  get roleGrantedSender(): RoleGrantedLoader {
    return new RoleGrantedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleGrantedSender"
    );
  }

  get roleAdminChangedSender(): RoleAdminChangedLoader {
    return new RoleAdminChangedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleAdminChangedSender"
    );
  }

  get roleLabelSender(): RoleLabelLoader {
    return new RoleLabelLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleLabelSender"
    );
  }

  get roleRevoked(): RoleRevokedLoader {
    return new RoleRevokedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleRevoked"
    );
  }

  get roleRevokedSender(): RoleRevokedLoader {
    return new RoleRevokedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleRevokedSender"
    );
  }

  get targetAdminDelayUpdatedSender(): TargetAdminDelayUpdatedLoader {
    return new TargetAdminDelayUpdatedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "targetAdminDelayUpdatedSender"
    );
  }

  get targetClosed(): TargetClosedLoader {
    return new TargetClosedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "targetClosed"
    );
  }

  get targetClosedSender(): TargetClosedLoader {
    return new TargetClosedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "targetClosedSender"
    );
  }

  get targetFunctionRoleUpdated(): TargetFunctionRoleUpdatedLoader {
    return new TargetFunctionRoleUpdatedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "targetFunctionRoleUpdated"
    );
  }

  get targetFunctionRoleUpdatedSender(): TargetFunctionRoleUpdatedLoader {
    return new TargetFunctionRoleUpdatedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "targetFunctionRoleUpdatedSender"
    );
  }

  get authorityUpdated(): AuthorityUpdatedLoader {
    return new AuthorityUpdatedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "authorityUpdated"
    );
  }

  get authorityUpdatedSender(): AuthorityUpdatedLoader {
    return new AuthorityUpdatedLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "authorityUpdatedSender"
    );
  }

  get transactions(): TransactionLoader {
    return new TransactionLoader(
      "Account",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "transactions"
    );
  }
}

export class Role extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Role entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Role must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Role", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Role | null {
    return changetype<Role | null>(store.get_in_block("Role", id));
  }

  static load(id: string): Role | null {
    return changetype<Role | null>(store.get("Role", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get roleOf(): AccessManagerRoleLoader {
    return new AccessManagerRoleLoader(
      "Role",
      this.get("id")!.toString(),
      "roleOf"
    );
  }

  get targetFunctionRoleUpdated(): TargetFunctionRoleUpdatedLoader {
    return new TargetFunctionRoleUpdatedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "targetFunctionRoleUpdated"
    );
  }

  get roleAdminChangedRole(): RoleAdminChangedLoader {
    return new RoleAdminChangedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleAdminChangedRole"
    );
  }

  get roleAdminChangedAdmin(): RoleAdminChangedLoader {
    return new RoleAdminChangedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleAdminChangedAdmin"
    );
  }

  get roleGrantDelayChanged(): RoleGrantDelayChangedLoader {
    return new RoleGrantDelayChangedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleGrantDelayChanged"
    );
  }

  get roleGranted(): RoleGrantedLoader {
    return new RoleGrantedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleGranted"
    );
  }

  get roleGuardianChangedRole(): RoleGuardianChangedLoader {
    return new RoleGuardianChangedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleGuardianChangedRole"
    );
  }

  get roleGuardianChangedGuardian(): RoleGuardianChangedLoader {
    return new RoleGuardianChangedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleGuardianChangedGuardian"
    );
  }

  get roleLabel(): RoleLabelLoader {
    return new RoleLabelLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleLabel"
    );
  }

  get roleRevoked(): RoleRevokedLoader {
    return new RoleRevokedLoader(
      "Role",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "roleRevoked"
    );
  }
}

export class Selector extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Selector entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Selector must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Selector", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Selector | null {
    return changetype<Selector | null>(
      store.get_in_block("Selector", id.toHexString())
    );
  }

  static load(id: Bytes): Selector | null {
    return changetype<Selector | null>(store.get("Selector", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get functionOf(): AccessManagerTargetFunctionLoader {
    return new AccessManagerTargetFunctionLoader(
      "Selector",
      this.get("id")!.toString(),
      "functionOf"
    );
  }

  get targetFunctionRoleUpdated(): TargetFunctionRoleUpdatedLoader {
    return new TargetFunctionRoleUpdatedLoader(
      "Selector",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "targetFunctionRoleUpdated"
    );
  }
}

export class Operation extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Operation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Operation must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Operation", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Operation | null {
    return changetype<Operation | null>(
      store.get_in_block("Operation", id.toHexString())
    );
  }

  static load(id: Bytes): Operation | null {
    return changetype<Operation | null>(
      store.get("Operation", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get operationOf(): AccessManagedOperationLoader {
    return new AccessManagedOperationLoader(
      "Operation",
      this.get("id")!.toString(),
      "operationOf"
    );
  }

  get operationCanceled(): OperationCanceledLoader {
    return new OperationCanceledLoader(
      "Operation",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "operationCanceled"
    );
  }

  get operationExecuted(): OperationExecutedLoader {
    return new OperationExecutedLoader(
      "Operation",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "operationExecuted"
    );
  }

  get operationScheduled(): OperationScheduledLoader {
    return new OperationScheduledLoader(
      "Operation",
      this.get("id")!
        .toBytes()
        .toHexString(),
      "operationScheduled"
    );
  }
}

export class DelayedBigInt extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelayedBigInt entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelayedBigInt must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelayedBigInt", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DelayedBigInt | null {
    return changetype<DelayedBigInt | null>(
      store.get_in_block("DelayedBigInt", id)
    );
  }

  static load(id: string): DelayedBigInt | null {
    return changetype<DelayedBigInt | null>(store.get("DelayedBigInt", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldValue(): BigInt {
    let value = this.get("oldValue");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set oldValue(value: BigInt) {
    this.set("oldValue", Value.fromBigInt(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get since(): BigInt {
    let value = this.get("since");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set since(value: BigInt) {
    this.set("since", Value.fromBigInt(value));
  }
}

export class Transaction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Transaction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Transaction", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Transaction | null {
    return changetype<Transaction | null>(
      store.get_in_block("Transaction", id.toHexString())
    );
  }

  static load(id: Bytes): Transaction | null {
    return changetype<Transaction | null>(
      store.get("Transaction", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class AccessManaged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccessManaged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AccessManaged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccessManaged", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AccessManaged | null {
    return changetype<AccessManaged | null>(
      store.get_in_block("AccessManaged", id.toHexString())
    );
  }

  static load(id: Bytes): AccessManaged | null {
    return changetype<AccessManaged | null>(
      store.get("AccessManaged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get authority(): Bytes {
    let value = this.get("authority");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set authority(value: Bytes) {
    this.set("authority", Value.fromBytes(value));
  }
}

export class AccessManager extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccessManager entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AccessManager must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccessManager", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AccessManager | null {
    return changetype<AccessManager | null>(
      store.get_in_block("AccessManager", id.toHexString())
    );
  }

  static load(id: Bytes): AccessManager | null {
    return changetype<AccessManager | null>(
      store.get("AccessManager", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get targets(): AccessManagerTargetLoader {
    return new AccessManagerTargetLoader(
      "AccessManager",
      this.get("id")!.toString(),
      "targets"
    );
  }

  get roles(): AccessManagerRoleLoader {
    return new AccessManagerRoleLoader(
      "AccessManager",
      this.get("id")!.toString(),
      "roles"
    );
  }

  get members(): AccessManagerRoleMemberLoader {
    return new AccessManagerRoleMemberLoader(
      "AccessManager",
      this.get("id")!.toString(),
      "members"
    );
  }

  get functions(): AccessManagerTargetFunctionLoader {
    return new AccessManagerTargetFunctionLoader(
      "AccessManager",
      this.get("id")!.toString(),
      "functions"
    );
  }

  get operations(): AccessManagedOperationLoader {
    return new AccessManagedOperationLoader(
      "AccessManager",
      this.get("id")!.toString(),
      "operations"
    );
  }
}

export class AccessManagerTarget extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccessManagerTarget entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccessManagerTarget must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccessManagerTarget", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AccessManagerTarget | null {
    return changetype<AccessManagerTarget | null>(
      store.get_in_block("AccessManagerTarget", id)
    );
  }

  static load(id: string): AccessManagerTarget | null {
    return changetype<AccessManagerTarget | null>(
      store.get("AccessManagerTarget", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get adminDelay(): string {
    let value = this.get("adminDelay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set adminDelay(value: string) {
    this.set("adminDelay", Value.fromString(value));
  }

  get closed(): boolean {
    let value = this.get("closed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set closed(value: boolean) {
    this.set("closed", Value.fromBoolean(value));
  }

  get functions(): AccessManagerTargetFunctionLoader {
    return new AccessManagerTargetFunctionLoader(
      "AccessManagerTarget",
      this.get("id")!.toString(),
      "functions"
    );
  }
}

export class AccessManagerRole extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccessManagerRole entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccessManagerRole must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccessManagerRole", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AccessManagerRole | null {
    return changetype<AccessManagerRole | null>(
      store.get_in_block("AccessManagerRole", id)
    );
  }

  static load(id: string): AccessManagerRole | null {
    return changetype<AccessManagerRole | null>(
      store.get("AccessManagerRole", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get asRole(): string {
    let value = this.get("asRole");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set asRole(value: string) {
    this.set("asRole", Value.fromString(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get label(): string | null {
    let value = this.get("label");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set label(value: string | null) {
    if (!value) {
      this.unset("label");
    } else {
      this.set("label", Value.fromString(<string>value));
    }
  }

  get grantDelay(): string {
    let value = this.get("grantDelay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set grantDelay(value: string) {
    this.set("grantDelay", Value.fromString(value));
  }

  get admin(): string {
    let value = this.get("admin");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set admin(value: string) {
    this.set("admin", Value.fromString(value));
  }

  get guardian(): string {
    let value = this.get("guardian");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set guardian(value: string) {
    this.set("guardian", Value.fromString(value));
  }

  get adminOf(): AccessManagerRoleLoader {
    return new AccessManagerRoleLoader(
      "AccessManagerRole",
      this.get("id")!.toString(),
      "adminOf"
    );
  }

  get guardianOf(): AccessManagerRoleLoader {
    return new AccessManagerRoleLoader(
      "AccessManagerRole",
      this.get("id")!.toString(),
      "guardianOf"
    );
  }

  get members(): AccessManagerRoleMemberLoader {
    return new AccessManagerRoleMemberLoader(
      "AccessManagerRole",
      this.get("id")!.toString(),
      "members"
    );
  }

  get functions(): AccessManagerTargetFunctionLoader {
    return new AccessManagerTargetFunctionLoader(
      "AccessManagerRole",
      this.get("id")!.toString(),
      "functions"
    );
  }
}

export class AccessManagerRoleMember extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AccessManagerRoleMember entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccessManagerRoleMember must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccessManagerRoleMember", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AccessManagerRoleMember | null {
    return changetype<AccessManagerRoleMember | null>(
      store.get_in_block("AccessManagerRoleMember", id)
    );
  }

  static load(id: string): AccessManagerRoleMember | null {
    return changetype<AccessManagerRoleMember | null>(
      store.get("AccessManagerRoleMember", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get asAccount(): Bytes {
    let value = this.get("asAccount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asAccount(value: Bytes) {
    this.set("asAccount", Value.fromBytes(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get since(): BigInt {
    let value = this.get("since");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set since(value: BigInt) {
    this.set("since", Value.fromBigInt(value));
  }

  get executionDelay(): string {
    let value = this.get("executionDelay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set executionDelay(value: string) {
    this.set("executionDelay", Value.fromString(value));
  }
}

export class AccessManagerTargetFunction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AccessManagerTargetFunction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccessManagerTargetFunction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccessManagerTargetFunction", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AccessManagerTargetFunction | null {
    return changetype<AccessManagerTargetFunction | null>(
      store.get_in_block("AccessManagerTargetFunction", id)
    );
  }

  static load(id: string): AccessManagerTargetFunction | null {
    return changetype<AccessManagerTargetFunction | null>(
      store.get("AccessManagerTargetFunction", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get asSelector(): Bytes {
    let value = this.get("asSelector");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asSelector(value: Bytes) {
    this.set("asSelector", Value.fromBytes(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get target(): string {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set target(value: string) {
    this.set("target", Value.fromString(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }
}

export class AccessManagedOperation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AccessManagedOperation entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccessManagedOperation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccessManagedOperation", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AccessManagedOperation | null {
    return changetype<AccessManagedOperation | null>(
      store.get_in_block("AccessManagedOperation", id)
    );
  }

  static load(id: string): AccessManagedOperation | null {
    return changetype<AccessManagedOperation | null>(
      store.get("AccessManagedOperation", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get schedule(): BigInt {
    let value = this.get("schedule");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set schedule(value: BigInt) {
    this.set("schedule", Value.fromBigInt(value));
  }

  get data(): Bytes {
    let value = this.get("data");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set data(value: Bytes) {
    this.set("data", Value.fromBytes(value));
  }

  get status(): string {
    let value = this.get("status");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get asOperation(): Bytes {
    let value = this.get("asOperation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set asOperation(value: Bytes) {
    this.set("asOperation", Value.fromBytes(value));
  }

  get manager(): Bytes {
    let value = this.get("manager");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set manager(value: Bytes) {
    this.set("manager", Value.fromBytes(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }
}

export class OperationCanceled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OperationCanceled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OperationCanceled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OperationCanceled", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): OperationCanceled | null {
    return changetype<OperationCanceled | null>(
      store.get_in_block("OperationCanceled", id.toHexString())
    );
  }

  static load(id: Bytes): OperationCanceled | null {
    return changetype<OperationCanceled | null>(
      store.get("OperationCanceled", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get operation(): Bytes {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set operation(value: Bytes) {
    this.set("operation", Value.fromBytes(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }
}

export class OperationExecuted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OperationExecuted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OperationExecuted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OperationExecuted", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): OperationExecuted | null {
    return changetype<OperationExecuted | null>(
      store.get_in_block("OperationExecuted", id.toHexString())
    );
  }

  static load(id: Bytes): OperationExecuted | null {
    return changetype<OperationExecuted | null>(
      store.get("OperationExecuted", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get operation(): Bytes {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set operation(value: Bytes) {
    this.set("operation", Value.fromBytes(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }
}

export class OperationScheduled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OperationScheduled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OperationScheduled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OperationScheduled", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): OperationScheduled | null {
    return changetype<OperationScheduled | null>(
      store.get_in_block("OperationScheduled", id.toHexString())
    );
  }

  static load(id: Bytes): OperationScheduled | null {
    return changetype<OperationScheduled | null>(
      store.get("OperationScheduled", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get operation(): Bytes {
    let value = this.get("operation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set operation(value: Bytes) {
    this.set("operation", Value.fromBytes(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get schedule(): BigInt {
    let value = this.get("schedule");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set schedule(value: BigInt) {
    this.set("schedule", Value.fromBigInt(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get data(): Bytes {
    let value = this.get("data");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set data(value: Bytes) {
    this.set("data", Value.fromBytes(value));
  }
}

export class RoleAdminChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleAdminChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleAdminChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleAdminChanged", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): RoleAdminChanged | null {
    return changetype<RoleAdminChanged | null>(
      store.get_in_block("RoleAdminChanged", id.toHexString())
    );
  }

  static load(id: Bytes): RoleAdminChanged | null {
    return changetype<RoleAdminChanged | null>(
      store.get("RoleAdminChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get admin(): string {
    let value = this.get("admin");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set admin(value: string) {
    this.set("admin", Value.fromString(value));
  }
}

export class RoleGrantDelayChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save RoleGrantDelayChanged entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleGrantDelayChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleGrantDelayChanged", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): RoleGrantDelayChanged | null {
    return changetype<RoleGrantDelayChanged | null>(
      store.get_in_block("RoleGrantDelayChanged", id.toHexString())
    );
  }

  static load(id: Bytes): RoleGrantDelayChanged | null {
    return changetype<RoleGrantDelayChanged | null>(
      store.get("RoleGrantDelayChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }

  get since(): BigInt {
    let value = this.get("since");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set since(value: BigInt) {
    this.set("since", Value.fromBigInt(value));
  }
}

export class RoleGranted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleGranted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleGranted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleGranted", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): RoleGranted | null {
    return changetype<RoleGranted | null>(
      store.get_in_block("RoleGranted", id.toHexString())
    );
  }

  static load(id: Bytes): RoleGranted | null {
    return changetype<RoleGranted | null>(
      store.get("RoleGranted", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }

  get since(): BigInt {
    let value = this.get("since");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set since(value: BigInt) {
    this.set("since", Value.fromBigInt(value));
  }

  get newMember(): boolean {
    let value = this.get("newMember");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set newMember(value: boolean) {
    this.set("newMember", Value.fromBoolean(value));
  }
}

export class RoleGuardianChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleGuardianChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleGuardianChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleGuardianChanged", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): RoleGuardianChanged | null {
    return changetype<RoleGuardianChanged | null>(
      store.get_in_block("RoleGuardianChanged", id.toHexString())
    );
  }

  static load(id: Bytes): RoleGuardianChanged | null {
    return changetype<RoleGuardianChanged | null>(
      store.get("RoleGuardianChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get guardian(): string {
    let value = this.get("guardian");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set guardian(value: string) {
    this.set("guardian", Value.fromString(value));
  }
}

export class RoleLabel extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleLabel entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleLabel must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleLabel", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): RoleLabel | null {
    return changetype<RoleLabel | null>(
      store.get_in_block("RoleLabel", id.toHexString())
    );
  }

  static load(id: Bytes): RoleLabel | null {
    return changetype<RoleLabel | null>(
      store.get("RoleLabel", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get label(): string {
    let value = this.get("label");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set label(value: string) {
    this.set("label", Value.fromString(value));
  }
}

export class RoleRevoked extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleRevoked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type RoleRevoked must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleRevoked", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): RoleRevoked | null {
    return changetype<RoleRevoked | null>(
      store.get_in_block("RoleRevoked", id.toHexString())
    );
  }

  static load(id: Bytes): RoleRevoked | null {
    return changetype<RoleRevoked | null>(
      store.get("RoleRevoked", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }
}

export class TargetAdminDelayUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TargetAdminDelayUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TargetAdminDelayUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TargetAdminDelayUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): TargetAdminDelayUpdated | null {
    return changetype<TargetAdminDelayUpdated | null>(
      store.get_in_block("TargetAdminDelayUpdated", id.toHexString())
    );
  }

  static load(id: Bytes): TargetAdminDelayUpdated | null {
    return changetype<TargetAdminDelayUpdated | null>(
      store.get("TargetAdminDelayUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get delay(): BigInt {
    let value = this.get("delay");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set delay(value: BigInt) {
    this.set("delay", Value.fromBigInt(value));
  }

  get since(): BigInt {
    let value = this.get("since");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set since(value: BigInt) {
    this.set("since", Value.fromBigInt(value));
  }
}

export class TargetClosed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TargetClosed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TargetClosed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TargetClosed", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): TargetClosed | null {
    return changetype<TargetClosed | null>(
      store.get_in_block("TargetClosed", id.toHexString())
    );
  }

  static load(id: Bytes): TargetClosed | null {
    return changetype<TargetClosed | null>(
      store.get("TargetClosed", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get closed(): boolean {
    let value = this.get("closed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set closed(value: boolean) {
    this.set("closed", Value.fromBoolean(value));
  }
}

export class TargetFunctionRoleUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save TargetFunctionRoleUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TargetFunctionRoleUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TargetFunctionRoleUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): TargetFunctionRoleUpdated | null {
    return changetype<TargetFunctionRoleUpdated | null>(
      store.get_in_block("TargetFunctionRoleUpdated", id.toHexString())
    );
  }

  static load(id: Bytes): TargetFunctionRoleUpdated | null {
    return changetype<TargetFunctionRoleUpdated | null>(
      store.get("TargetFunctionRoleUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get target(): Bytes {
    let value = this.get("target");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set target(value: Bytes) {
    this.set("target", Value.fromBytes(value));
  }

  get selector(): Bytes {
    let value = this.get("selector");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set selector(value: Bytes) {
    this.set("selector", Value.fromBytes(value));
  }

  get role(): string {
    let value = this.get("role");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set role(value: string) {
    this.set("role", Value.fromString(value));
  }
}

export class AuthorityUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AuthorityUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AuthorityUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AuthorityUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AuthorityUpdated | null {
    return changetype<AuthorityUpdated | null>(
      store.get_in_block("AuthorityUpdated", id.toHexString())
    );
  }

  static load(id: Bytes): AuthorityUpdated | null {
    return changetype<AuthorityUpdated | null>(
      store.get("AuthorityUpdated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get transaction(): Bytes {
    let value = this.get("transaction");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transaction(value: Bytes) {
    this.set("transaction", Value.fromBytes(value));
  }

  get emitter(): Bytes {
    let value = this.get("emitter");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set emitter(value: Bytes) {
    this.set("emitter", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get authority(): Bytes {
    let value = this.get("authority");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set authority(value: Bytes) {
    this.set("authority", Value.fromBytes(value));
  }
}

export class AccessManagerRoleMemberLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessManagerRoleMember[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessManagerRoleMember[]>(value);
  }
}

export class AccessManagerTargetLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessManagerTarget[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessManagerTarget[]>(value);
  }
}

export class AccessManagedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessManaged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessManaged[]>(value);
  }
}

export class AccessManagedOperationLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessManagedOperation[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessManagedOperation[]>(value);
  }
}

export class OperationExecutedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): OperationExecuted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<OperationExecuted[]>(value);
  }
}

export class OperationScheduledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): OperationScheduled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<OperationScheduled[]>(value);
  }
}

export class RoleGrantedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleGranted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleGranted[]>(value);
  }
}

export class RoleAdminChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleAdminChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleAdminChanged[]>(value);
  }
}

export class RoleLabelLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleLabel[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleLabel[]>(value);
  }
}

export class RoleRevokedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleRevoked[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleRevoked[]>(value);
  }
}

export class TargetAdminDelayUpdatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TargetAdminDelayUpdated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TargetAdminDelayUpdated[]>(value);
  }
}

export class TargetClosedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TargetClosed[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TargetClosed[]>(value);
  }
}

export class TargetFunctionRoleUpdatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TargetFunctionRoleUpdated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TargetFunctionRoleUpdated[]>(value);
  }
}

export class AuthorityUpdatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AuthorityUpdated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AuthorityUpdated[]>(value);
  }
}

export class TransactionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Transaction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Transaction[]>(value);
  }
}

export class AccessManagerRoleLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessManagerRole[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessManagerRole[]>(value);
  }
}

export class RoleGrantDelayChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleGrantDelayChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleGrantDelayChanged[]>(value);
  }
}

export class RoleGuardianChangedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): RoleGuardianChanged[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<RoleGuardianChanged[]>(value);
  }
}

export class AccessManagerTargetFunctionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AccessManagerTargetFunction[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AccessManagerTargetFunction[]>(value);
  }
}

export class OperationCanceledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): OperationCanceled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<OperationCanceled[]>(value);
  }
}
